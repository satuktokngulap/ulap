from subprocess import CalledProcessError, Popen, PIPE
from optparse import OptionParser, make_option
from ConfigParser import ConfigParser
import shlex, pexpect, os, logging, sys, pprint, re, time, random

class RDPException(Exception):
    pass

class CommandCallException(RDPException):
    pass

class ConfigNotFoundException(RDPException):
    pass

class LoadException(RDPException):
    pass

class ConnectException(RDPException):
    pass


def command_line_call_and_return(command_string, exit_on_error=True, suppress_warnings=False):
    """
        Splices the command string and feeds it to subprocess.check_call(),
          which accepts a list
        It basically feeds the command line commands and execute them as they
          would on a terminal
        Use three doublequotes (\"\"") to feed commands as strings to avoid
          the need to escape single quotes or double quotes
        Returns the output of the command as a string
          instead of putting it in terminal
        If suppress_warnings is set to true, returns a tuple
          (stdout_output,stderr_output)
    """

    command_list = shlex.split(command_string)

    try:
        #return Popen(["pip","freeze","-E","env/"], stdout=PIPE).communicate()[0]
        if suppress_warnings:
            return Popen(command_list, stdout=PIPE, stderr=PIPE).communicate()
        else:
            return Popen(command_list, stdout=PIPE).communicate()[0]
    except CalledProcessError, details:

        err_msg = """\nERROR: Bash call from script failed!\n
        Bash command(s): %s\n
        DETAILS: 
        %s""" % (command_string, details)
        
        
        if(exit_on_error):
            logging.error(err_msg)
            sys.exit("Exited due to error")
        else:
            raise CommandCallException(err_msg)

def get_cwd():
    """
        Returns the current working directory 
          of this script
        If executed from binary, removes the temp extension folder
          generated by the binary
    """
    path = os.path.realpath(__file__)
    if "?" in path:
        return path.rpartition("?")[0].rpartition("/")[0]+"/"
    else:
        return path.rpartition("/")[0]+"/"
    #"""
    #path = os.path.realpath(__file__)
    return path.rpartition("/")[0]+"/"

def check_file_exists(path_to_file):
    """
        Checks if file <path_to_file> exists
    """
    try:
        with open(path_to_file): pass
        return True
    except IOError:
        return False

def parse_config(path_to_config):
    """
        Parse the config.ini file found in the same folder
        If not found, log the error and exit
    """
    if check_file_exists(path_to_config):
        pass
    else:
        err_msg = "Config file 'config.ini' not found in folder:\n   " + get_cwd()
        raise ConfigNotFoundException(err_msg)
        
    config = ConfigParser()
    config.read(path_to_config)
    return config

def config_map(section, config):
    dict1 = {}
    options = config.options(section)
    for option in options:
        try:
            dict1[option] = config.get(section, option)
            if dict1[option] == -1:
                logging.debug("[CONFIG MAP] skip: %s" % option)
        except:
            logging.error("[CONFIG MAP] exception on %s!" % option)
            dict1[option] = None
    return dict1


